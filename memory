# Product Requirement Document of Mochi Chat

## Project Overview
Mochi Chat is a browser extension that provides intelligent chat functionality, with capabilities for handling various types of content including PDFs and web content. It features a floating chat interface that can be toggled and positioned anywhere on the webpage.

## Core Components

### Background Script (background.js)
Core extension functionality and messaging handler.

Key Features:
1. Logging System
   - Timestamp-based logging with module identification
   - Error vs standard log differentiation
   - Source module tracking (Mochi-Background, Mochi-Content, Mochi-Chat)
   - Console output formatting with timestamps

2. Message Handling System
   - Actions:
     * checkFilePermission: Verifies local file access permissions
     * openExtensionsPage: Opens Chrome extensions page for configuration
     * logFromContent: Processes logs from content scripts
     * conversationUpdated: Tracks conversation history changes
     * fetchLocalPDF: Handles local PDF file retrieval
   - Asynchronous response handling
   - Error tracking and reporting

3. PDF Processing
   - Local PDF file handling
   - Base64 encoding for PDF data
   - File URL processing
   - Error handling for file access issues

### Content Script (content.js)
Primary script managing extension's webpage presence.

Key Features:
1. Global State Management
   - Variables:
     * chatInterface: Main chat interface reference
     * toggleButton: Toggle button reference
     * isInterfaceVisible: Chat visibility state
     * extractModule: Text extraction module reference
     * lastResponse: Last AI response storage
     * initialized: Initialization state flag
     * chatModule: Chat module reference
     * accumulatedResponse: Response accumulation from chat.js

2. Chat Toggle Button
   - Creation and Injection:
     * SVG-based chat icon
     * Flex display centering
     * Click event listener
     * Dynamic visibility control
   - Error handling with background logging

3. Chat Interface Creation
   - HTML Structure:
     * Container with unique ID
     * Custom font loading (Noto Sans)
     * Dynamic title based on content type
     * Expand/collapse buttons
     * Close button
   - Styling:
     * Custom CSS injection
     * Responsive design
     * Font consistency

4. Text Extraction
   - Dynamic module loading
   - Content type detection (PDF vs website)
   - Page text processing
   - Link creation for page references

5. Response Handling
   - Streaming updates processing
   - Markdown rendering
   - Error state management
   - UI state reset functionality

6. Utility Functions
   - renderMarkdown: Configurable markdown processing
   - createPageLinks: PDF page reference linking
   - logToBackground: Structured logging
   - showError: Error display handling

7. Initialization Flow
   - Document ready state checking
   - Sequential component initialization
   - Error recovery mechanisms
   - State validation

### Chat Module (chat.js)
OpenAI integration and chat functionality handler.

Key Features:
1. API Integration
   - Secure API key management
   - OpenAI API endpoint handling
   - Error handling and retry logic

2. Response Generation
   - Stream handling:
     * Chunk processing
     * Response accumulation
     * Error detection
   - History integration with conversation.js
   - Background logging with [Mochi-Chat] identifier

3. Message Management
   - Content script communication
   - Custom event dispatching
   - Error handling and recovery
   - Response formatting

### Conversation Manager (conversation.js)
Conversation state and history management.

Key Features:
1. System Instructions
   - Response formatting rules:
     * Concise responses requirement
     * Bullet point usage guidelines
     * Page-specific response rules
     * Calculation formatting requirements

2. History Management
   - Data structures:
     * conversationHistory array
     * Message format {role, content}
   - Operations:
     * addExtractedText: Adds document context
     * addToHistory: Appends new messages
     * clearHistory: Resets conversation
     * getHistory: Retrieves current state

3. Text Processing
   - System message formatting
   - Context preservation
   - History validation
   - Error handling

### Text Extraction Module (extract-text.js)
Handles text extraction from different content types.

Key Features:
1. Website Text Extraction
   - Focus on meaningful content elements:
     * HTML5 semantic: p, h1-h6, article, section, main, time, q, cite
     * List elements: li, dt, dd
     * Table elements: td, th
     * Quote elements: blockquote, figcaption
   - Common content classes:
     * Article: .article-body, .post-content, .entry-content
     * Main content: .main-text, .content
     * Special content: .data-visualization-text, .video-transcript
     * FAQ sections: .faq, .question, .answer
   - Common content IDs:
     * #main-content, #article-text, #post-body
     * #content, #main, #article
   - Exclude non-content elements:
     * Layout elements: footer, aside, canvas
     * UI elements: .popup, .modal, .overlay, .cookie-banner
     * Promotional: .ad, .advertisement, .promotion, .sponsor
     * Navigation: .sidebar, .widget, #menu
     * Technical: script, style, iframe, code blocks
     * Analytics: .tracking, .analytics, .third-party
     * Common IDs: #footer, #sidebar, #ad-banner, #banner
   - Smart content detection with fallback
   - Proper text formatting and cleaning
   - Block-level element handling
   - Duplicate content prevention
   - Visibility checks (display, opacity, dimensions)

2. PDF Text Extraction
   - PDF.js integration
   - Local and remote PDF handling
   - Character mapping support
   - Page-by-page processing
   - Text positioning and layout handling

3. Logging System
   - Module-specific logging ([Mochi-Extract])
   - Detailed progress tracking
   - Error reporting with full context
   - Text content validation

### Website Text Extraction Implementation

### Content Selection Strategy
1. Content Elements:
   * HTML5 Semantic Elements:
     - Headings and paragraphs: p, h1-h6
     - Sections: article, section, main
     - Lists: li, dl, dt, dd, ul, ol
     - Tables: td, th, caption
     - Rich elements: time, q, cite, details, summary
   
   * Rich Semantic Roles:
     - [role="article"]
     - [role="main"]
     - [role="contentinfo"]
     - [role="complementary"]
     - header[role="heading"]
   
   * Web App Elements:
     - Grid: [role="gridcell"], [role="row"]
     - Lists: [role="list"], [role="listitem"]
     - Messages: .message, .conversation, .thread
     - Email: .email-body, .mail-content, .preview-text
     - UI: .card-content, .panel-content, .tab-content
     - Rich text: [role="textbox"], [contenteditable="true"]
     - Document: [role="document"], .dashboard-content
     - Test IDs: [data-testid*="content"], [data-testid*="text"]
     - Aria: [aria-label*="content"], [aria-label*="text"]
   
   * Forms and Controls:
     - Forms: form, fieldset, legend, label
     - Inputs: input[type="text"], textarea

2. Excluded Elements:
   * Technical:
     - Scripts and styles
     - iframes and canvas
     - Code blocks
   
   * Navigation and Menu:
     - nav, [role="navigation"]
     - .menu-item, .nav-item
     - .navigation, .navbar
     - .breadcrumb, .pagination
   
   * Metadata and Info:
     - .meta, .metadata
     - .article-meta, .post-meta
     - .author-info, .publish-date
     - .info-box, .info-panel
     - .byline, .dateline
     - .timestamp, .time-info
   
   * Interactive:
     - Buttons and button-like elements
     - Dropdowns and selects
     - Menu items
   
   * UI Elements:
     - Popups and modals
     - Tooltips and badges
     - Loading indicators
   
   * Web App UI:
     - Toolbars and status bars
     - Navigation and command bars
     - Editor UI elements
     - Tree views and list headers
     - Progress and status indicators
     - Search and filter boxes

3. Implementation Details:
   * DOM Loading:
     - Waits for document.readyState === 'complete'
     - Retries content check up to 3 times
     - 2-second delay between retries
   
   * Content Filtering:
     - Simple visibility check (display, visibility, opacity)
     - Duplicate check within 3 parent levels
     - Exact text match for duplicates
   
   * Text Processing:
     - Whitespace normalization
     - Block element formatting
     - Title preservation

### Implementation Notes:
- Uses temporary DOM attribute (data-mochi-excluded) for efficient filtering
- Fallback to body elements if no content elements found
- Maintains original DOM state after extraction
- Comprehensive logging at each phase for debugging

### Styles (styles.css)
Custom styling system.

Key Features:
1. Chat Interface Styling
   - Container positioning
   - Responsive design
   - Animation effects
   - Z-index management

2. Typography
   - Noto Sans integration
   - Font size hierarchy
   - Line height optimization
   - Text color system

3. Button Styling
   - Toggle button design
   - Action button states
   - Hover effects
   - Icon integration

4. Layout Management
   - Flexbox implementation
   - Grid systems
   - Spacing utilities
   - Responsive breakpoints

## Development Guidelines

### Code Organization and Documentation
1. Code Documentation Requirements:
   - Each section must include detailed comments explaining its purpose and necessity
   - Function documentation must include:
     * Parameter descriptions
     * Return value specifications
     * Usage examples where appropriate
   Example:
   ```javascript
   /**
    * @param {object} sender - Sender information for message passing
    * @returns {object} Updated accumulated response and any error
    */
   ```

2. Import Strategy:
   - Use dynamic imports with chrome.runtime.getURL instead of static imports
   - Example: `await import(chrome.runtime.getURL('module.js'))`

3. Debugging Standards:
   - All debug logs must be in background script console
   - Log format must identify source module:
     * [Mochi-Background] for background script logs
     * [Mochi-Content] for content script logs
     * [Mochi-Chat] for chat interface logs

4. Code Modification Protocol:
   - Preserve existing code unless absolutely necessary to change
   - Consider future use cases before removing any code

### Documentation Maintenance
- Update this memory file for all new requirements
- Review this file before making any changes
- Document conflicting requirements and seek clarification
- Record bug resolutions in Tips section

## Tips for Myself
1. PDF Text Extraction
   - Always handle both local and remote PDFs differently
   - Use background script for local PDF access
   - Ensure proper character mapping with cmaps
   - Check PDF data size in logs

2. Website Text Extraction
   - Focus on semantic HTML elements first
   - Exclude code blocks and their containers
   - Check for parent-child content duplication
   - Handle block-level elements with proper spacing
   - Validate element visibility thoroughly (display, opacity, dimensions)
